<!doctype html>
<html lang="bn">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Scrollytelling Timeline (Fullscreen, Interactive, No-crop Main Image)</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Bengali:wght@400;600;700&display=swap" rel="stylesheet">

  <style>
    :root{ --headerH: 112px; }
    @media (max-width: 900px){ :root{ --headerH: 96px; } }

    body { margin:0; font-family:"Noto Sans Bengali", system-ui, sans-serif; background:#000; }

    /* ===== Sticky timeline header ===== */
    .timeline-sticky{
      position: sticky; top: 0; z-index: 50;
      background:#fff;
      border-bottom: 1px solid #eee;
      padding: 14px 16px 10px;
    }
    .topline{ display:flex; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .title{ font-weight: 800; }

    .timeline-wrap{
      position: relative;
      height: 86px;
      margin-top: 10px;
      touch-action: pan-y;
      user-select: none;
    }

    .track{
      position:absolute; left:0; right:0; top:28px;
      height:6px; border-radius:999px; background:#eee;
      cursor: pointer;
    }
    .progress{
      position:absolute; left:0; top:28px;
      height:6px; border-radius:999px; background:#111;
      width:0%;
      transition: width 140ms linear;
      pointer-events:none;
    }
    .playhead{
      position:absolute; top:18px; left:0%;
      width:18px; height:18px; border-radius:50%;
      background:#111; transform:translateX(-50%);
      transition:left 140ms linear;
      cursor: grab;
      touch-action: none;
    }
    .playhead:active{ cursor: grabbing; }

    /* Tick marks */
    .ticks{ position:absolute; left:0; right:0; top:20px; height:24px; }
    .tick{
      position:absolute; top:0;
      width: 18px; height: 24px;
      transform: translateX(-50%);
      display:flex; align-items:flex-end; justify-content:center;
      cursor:pointer;
    }
    .tick::before{
      content:"";
      width:2px; height:14px; border-radius:2px; background:#bbb;
    }
    .tick.is-active::before{ background:#111; height:18px; }

    .activeTimeCenter{
      position:absolute; left:50%; top:52px; transform:translateX(-50%);
      font-size: 13px; color:#444; font-weight:600; white-space:nowrap;
      pointer-events:none;
    }
    .labels{ margin-top: 8px; display:flex; justify-content:space-between; font-size:12px; color:#666; }

    /* ===== Background stage (fills remaining viewport, stable on mobile) ===== */
    .bgStage{
      position: sticky;
      top: var(--headerH);
      height: calc(100svh - var(--headerH));
      z-index: 1;
      overflow: hidden;
      background:#000;
      isolation: isolate; /* ensures overlay stacking behaves */
    }
    @supports not (height: 100svh){
      .bgStage{ height: calc(100vh - var(--headerH)); }
    }

    /* ===== OPTION 1: single image, optimized for PC+Mobile =====
       - bgFill: same image, cover + blur (fills screen; cropping doesn't matter)
       - bgMain: same image, contain (NO CROP EVER)
    */
    .bgFill, .bgMain{
      position:absolute; inset:0;
      width:100%; height:100%;
      opacity: 0;
      transition: opacity 620ms ease;
      will-change: opacity;
      pointer-events:none;
      user-select:none;
    }
    .bgFill.is-visible, .bgMain.is-visible{ opacity: 1; }

    .bgFill{
      object-fit: cover;
      filter: blur(22px);
      transform: scale(1.1);
      /* we keep it a bit dim so main image pops */
      opacity: 0; /* controlled by is-visible */
    }

    .bgMain{
      object-fit: contain;   /* FULL IMAGE VISIBLE (NO CROP) */
      background: #000;      /* bars behind image (hidden by blurred fill anyway) */
      opacity: 0;            /* controlled by is-visible */
    }

    /* ===== Added polish (as requested) ===== */
    .bgMain{
      object-fit: contain;
      padding: 4vh 6vw;   /* makes square image feel bigger on wide screens */
    }
    @media (max-width:900px){
      .bgMain{
        padding: 0;
      }
    }
    /* ====================================== */

    .bgOverlay{
      position:absolute; inset:0;
      background: linear-gradient(
        to bottom,
        rgba(0,0,0,.16) 0%,
        rgba(0,0,0,.40) 48%,
        rgba(0,0,0,.68) 100%
      );
      z-index: 3;
      pointer-events:none;
    }

    /* ===== Steps layer (scroll triggers) ===== */
    .scrolly{
      position: relative;
      z-index: 10;
      max-width: 1200px;
      margin: 0 auto;
      padding: 18px 16px 90px;
    }

    .step{
      min-height: 110vh;
      display:flex;
      align-items:flex-end;
      position: relative;
    }

    /* Left card */
    .card{
      position: sticky;
      bottom: 22px;
      width: 360px;
      max-width: calc(100% - 32px);
      margin-right: auto;

      background: rgba(240,240,240,.82);
      border: 1px solid rgba(255,255,255,.55);
      border-radius: 18px;
      padding: 14px 14px 16px;
      box-shadow: 0 14px 36px rgba(0,0,0,.30);
      backdrop-filter: blur(7px);

      opacity: 0;
      transform: translateY(22px);
      transition: opacity 280ms ease, transform 280ms ease;
      will-change: opacity, transform;

      max-height: 55vh;
      overflow-y: auto;
    }

    .step.is-active .card{
      opacity: 1;
      transform: translateY(0);
    }

    .when{ font-size: 12px; color:#111; opacity:.75; margin-bottom: 6px; }
    .card h3{ margin:0 0 8px 0; font-size: 20px; font-weight: 800; color:#111; }
    .card p{ margin:0; line-height: 1.7; font-size: 14px; color:#222; }

    @media (max-width: 900px){
      .step{ min-height: 135vh; }
      .card{ width: 320px; bottom: 16px; }
    }
    @media (max-width: 420px){
      .card{ width: calc(100% - 20px); }
    }
  </style>
</head>

<body>
  <header class="timeline-sticky">
    <div class="topline">
      <div class="title">ঢাকা: সংবাদপত্র অফিসে হামলা — স্ক্রল টাইমলাইন</div>
    </div>

    <div class="timeline-wrap" id="timelineWrap">
      <div class="track" id="track" aria-label="Timeline track"></div>
      <div class="progress" id="progress"></div>
      <div class="playhead" id="playhead"
           role="slider" aria-label="Timeline playhead"
           aria-valuemin="0" aria-valuemax="11" aria-valuenow="0" tabindex="0"></div>
      <div class="ticks" id="ticks"></div>
      <div class="activeTimeCenter" id="activeTime">সময়: —</div>
    </div>

    <div class="labels">
      <span>১৮ ডিসেম্বর ১০:০০ PM</span>
      <span>১৯ ডিসেম্বর ০৬:০০ PM</span>
    </div>
  </header>

  <!-- ===== Background stage: 1 image per scene, NO CROP MAIN ===== -->
  <div class="bgStage" aria-hidden="true">
    <!-- Blurred fill (cover) crossfade pair -->
    <img class="bgFill is-visible" id="fillA" alt="" decoding="async" fetchpriority="high">
    <img class="bgFill" id="fillB" alt="" decoding="async">

    <!-- Main (contain) crossfade pair -->
    <img class="bgMain is-visible" id="mainA" alt="" decoding="async" fetchpriority="high">
    <img class="bgMain" id="mainB" alt="" decoding="async">

    <div class="bgOverlay"></div>
  </div>

  <main class="scrolly">
    <section id="steps"></section>
  </main>

  <script src="https://unpkg.com/scrollama"></script>
  <script>
    // Prevent mobile “jump to last scroll position”
    if ("scrollRestoration" in history) history.scrollRestoration = "manual";
    window.addEventListener("load", () => window.scrollTo(0, 0));

    // =========================
    // EDIT ONLY THIS ARRAY
    // Use ONE image per scene (your 1600x2000 is fine)
    // =========================
    const SCENES = [
      { id:"s1",  progress:0/11,  timeLabel:"১৮ ডিসেম্বর ১০:০২ PM", titleBn:"শিরোনাম ১", longText:"ডামি লং টেক্সট (১)", image:"assets/scene1.jpg"  },
      { id:"s2",  progress:1/11,  timeLabel:"১৮ ডিসেম্বর ১০:২০ PM", titleBn:"শিরোনাম ২", longText:"ডামি লং টেক্সট (২)", image:"assets/scene2.jpg"  },
      { id:"s3",  progress:2/11,  timeLabel:"১৮ ডিসেম্বর ১০:৪০ PM", titleBn:"শিরোনাম ৩", longText:"ডামি লং টেক্সট (৩)", image:"assets/scene3.jpg"  },
      { id:"s4",  progress:3/11,  timeLabel:"১৮ ডিসেম্বর ১১:০৫ PM", titleBn:"শিরোনাম ৪", longText:"ডামি লং টেক্সট (৪)", image:"assets/scene4.jpg"  },
      { id:"s5",  progress:4/11,  timeLabel:"১৮ ডিসেম্বর ১১:৩০ PM", titleBn:"শিরোনাম ৫", longText:"ডামি লং টেক্সট (৫)", image:"assets/scene5.jpg"  },
      { id:"s6",  progress:5/11,  timeLabel:"১৮ ডিসেম্বর ১১:৪৫ PM", titleBn:"শিরোনাম ৬", longText:"ডামি লং টেক্সট (৬)", image:"assets/scene6.jpg"  },
      { id:"s7",  progress:6/11,  timeLabel:"১৯ ডিসেম্বর ১২:৩০ AM", titleBn:"শিরোনাম ৭", longText:"ডামি লং টেক্সট (৭)", image:"assets/scene7.jpg"  },
      { id:"s8",  progress:7/11,  timeLabel:"১৯ ডিসেম্বর ০২:১৫ AM", titleBn:"শিরোনাম ৮", longText:"ডামি লং টেক্সট (৮)", image:"assets/scene8.jpg"  },
      { id:"s9",  progress:8/11,  timeLabel:"১৯ ডিসেম্বর ০৭:৩০ AM", titleBn:"শিরোনাম ৯", longText:"ডামি লং টেক্সট (৯)", image:"assets/scene9.jpg"  },
      { id:"s10", progress:9/11,  timeLabel:"১৯ ডিসেম্বর ০৯:৩০ AM", titleBn:"শিরোনাম ১০", longText:"ডামি লং টেক্সট (১০)", image:"assets/scene10.jpg" },
      { id:"s11", progress:10/11, timeLabel:"১৯ ডিসেম্বর ০১:৪৫ PM", titleBn:"বিতর্ক/পাল্টাপাল্টি", longText:"ডামি লং টেক্সট (১১)", image:"assets/scene11.jpg" },
      { id:"s12", progress:11/11, timeLabel:"১৯ ডিসেম্বর ০৬:০০ PM", titleBn:"শেষ পর্যায়", longText:"ডামি লং টেক্সট (১২)", image:"assets/scene12.jpg" }
    ];

    // ===== Build steps (scroll triggers) =====
    const stepsRoot = document.getElementById("steps");
    SCENES.forEach((s, idx) => {
      const el = document.createElement("div");
      el.className = "step";
      el.dataset.index = idx;
      el.innerHTML = `
        <div class="card">
          <div class="when">${s.timeLabel}</div>
          <h3>${s.titleBn}</h3>
          <p>${escapeHtml(s.longText)}</p>
        </div>
      `;
      stepsRoot.appendChild(el);
    });

    // ===== Build ticks =====
    const ticksRoot = document.getElementById("ticks");
    const tickEls = [];
    SCENES.forEach((s, idx) => {
      const t = document.createElement("div");
      t.className = "tick";
      t.style.left = (Math.max(0, Math.min(1, s.progress)) * 100) + "%";
      t.dataset.index = idx;
      t.title = s.timeLabel;
      t.addEventListener("click", () => scrollToStep(idx));
      ticksRoot.appendChild(t);
      tickEls.push(t);
    });

    // ===== Timeline UI =====
    const timelineWrap = document.getElementById("timelineWrap");
    const track = document.getElementById("track");
    const playhead = document.getElementById("playhead");
    const progressBar = document.getElementById("progress");
    const activeTime = document.getElementById("activeTime");

    // ===== Background crossfade (NEW implementation, rest unchanged) =====
    const fillA = document.getElementById("fillA");
    const fillB = document.getElementById("fillB");
    const mainA = document.getElementById("mainA");
    const mainB = document.getElementById("mainB");

    let fillFront = fillA, fillBack = fillB;
    let mainFront = mainA, mainBack = mainB;
    let currentIdx = -1;

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    function setTimelineUI(idx){
      const s = SCENES[idx];
      const pct = clamp01(s.progress) * 100;
      playhead.style.left = pct + "%";
      progressBar.style.width = pct + "%";
      tickEls.forEach(x => x.classList.remove("is-active"));
      tickEls[idx]?.classList.add("is-active");
      activeTime.textContent = "সময়: " + (s.timeLabel || "—");
      playhead.setAttribute("aria-valuenow", String(idx));
    }

    function crossFadeTo(url){
      // set sources on "back" images
      fillBack.src = url;
      mainBack.src = url;

      // fade in back
      fillBack.classList.add("is-visible");
      mainBack.classList.add("is-visible");

      // fade out front
      fillFront.classList.remove("is-visible");
      mainFront.classList.remove("is-visible");

      // swap references
      const tmpFill = fillFront; fillFront = fillBack; fillBack = tmpFill;
      const tmpMain = mainFront; mainFront = mainBack; mainBack = tmpMain;
    }

    function renderScene(idx){
      const s = SCENES[idx];
      if (idx !== currentIdx) {
        if (currentIdx === -1) {
          // first paint
          fillFront.src = s.image;
          mainFront.src = s.image;
          fillFront.classList.add("is-visible");
          mainFront.classList.add("is-visible");
        } else {
          crossFadeTo(s.image);
        }
        currentIdx = idx;
      }
      setTimelineUI(idx);
    }

    // ===== Card fade timing (control here) =====
    function setCardProgress(stepEl, progress){
      const card = stepEl.querySelector(".card");
      if (!card) return;

      // Fade starts later and lasts longer (tweak these)
      const hold = 0.78;     // fully visible until 78% of step
      const fadeSpan = 0.28; // fade across next 28% of step

      let alpha = 1;
      if (progress > hold) {
        const t = Math.min(1, (progress - hold) / fadeSpan);
        alpha = 1 - t;
      }
      alpha = Math.max(0.06, alpha);

      card.style.opacity = String(alpha);
      card.style.transform = `translateY(${(1 - alpha) * -25}px)`;
    }

    // ===== Scrollama =====
    const scroller = scrollama();
    scroller.setup({ step: ".step", offset: 0.6, progress: true })
      .onStepEnter(({ element, index }) => {
        document.querySelectorAll(".step").forEach(x => x.classList.remove("is-active"));
        element.classList.add("is-active");
        renderScene(index);
        setCardProgress(element, 0);
      })
      .onStepProgress(({ element, progress }) => setCardProgress(element, progress))
      .onStepExit(({ element }) => {
        const card = element.querySelector(".card");
        if (card) { card.style.opacity = ""; card.style.transform = ""; }
      });

    // ===== Click/Drag timeline =====
    let isDragging = false;
    let dragRaf = 0;

    function getPctFromClientX(clientX){
      const r = timelineWrap.getBoundingClientRect();
      return clamp01((clientX - r.left) / r.width);
    }
    function idxFromPct(pct){
      return Math.round(pct * (SCENES.length - 1));
    }

    function scrollToStep(idx){
      const stepEl = document.querySelector(`.step[data-index="${idx}"]`);
      if (!stepEl) return;
      stepEl.scrollIntoView({ behavior: "smooth", block: "start" });
    }

    function seekByClientX(clientX){
      const pct = getPctFromClientX(clientX);
      const idx = idxFromPct(pct);
      setTimelineUI(idx);   // immediate UI response
      scrollToStep(idx);    // actual navigation
    }

    // Click on track
    track.addEventListener("pointerdown", (e) => {
      track.setPointerCapture(e.pointerId);
      seekByClientX(e.clientX);
    });

    // Drag playhead
    playhead.addEventListener("pointerdown", (e) => {
      isDragging = true;
      playhead.setPointerCapture(e.pointerId);
      playhead.style.transition = "none";
      progressBar.style.transition = "none";
      e.preventDefault();
    });

    playhead.addEventListener("pointermove", (e) => {
      if (!isDragging) return;
      const pct = getPctFromClientX(e.clientX);
      const idx = idxFromPct(pct);

      if (dragRaf) cancelAnimationFrame(dragRaf);
      dragRaf = requestAnimationFrame(() => setTimelineUI(idx));
    });

    playhead.addEventListener("pointerup", (e) => {
      if (!isDragging) return;
      isDragging = false;
      playhead.releasePointerCapture(e.pointerId);
      playhead.style.transition = "";
      progressBar.style.transition = "";
      const pct = getPctFromClientX(e.clientX);
      scrollToStep(idxFromPct(pct));
    });

    playhead.addEventListener("pointercancel", () => { isDragging = false; });

    // Keyboard support
    playhead.addEventListener("keydown", (e) => {
      const active = Number(playhead.getAttribute("aria-valuenow") || "0");
      if (e.key === "ArrowRight") { e.preventDefault(); scrollToStep(Math.min(SCENES.length-1, active+1)); }
      if (e.key === "ArrowLeft")  { e.preventDefault(); scrollToStep(Math.max(0, active-1)); }
    });

    // Initial render
    renderScene(0);
    document.querySelector(".step")?.classList.add("is-active");

    // Resize stability
    function onResize(){ scroller.resize(); }
    window.addEventListener("resize", onResize);
    window.addEventListener("orientationchange", onResize);
    setTimeout(onResize, 80);
    setTimeout(onResize, 350);

    function escapeHtml(str){
      return String(str ?? "").replace(/[&<>"']/g, ch => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
      }[ch]));
    }
  </script>
</body>
</html>
